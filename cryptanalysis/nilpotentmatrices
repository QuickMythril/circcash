# The code is in GAP.
# Let L be the irreducible representation of the permutation group S_n of degree n-1. The following code finds permutations f_1,...,f_p such that L(f_1)+...+L(f_p) is nilpotent
# in the extreme case where p is prime, n=p^nn. Such lists are permutations may be useful for analyzing block ciphers where the round keys have small block size (such as 32 bit)
# and small round key size (such as 1 bit).

# There are algorithms that are able to produce new nilpotent matrices from old ones, but these soft-algorithms cannot easily take a matrix that is not nilpotent and make it
# nilpotent.

# We have found maps L(f_1)+...+L(f_p) which are nilpotent of nullity 1 when p=2,3<=nn<=5 or when p=3,2<=nn<=3 or when p=5,nn=2.

# Here is the data for when p=2,nn=5.
# f=(1,â€¦,32),g=(2,15,19,11,8,24,16)(3,25,6,10,21,17,32,5,30,18,12,26,29)(4,13,31,23,22)(7,20,28,14,9).


# here is the data when p=3;nn=3.
#[ [ 1, 2, 3 ], [ 4, 5, 21 ], [ 7, 24, 26 ], [ 14, 17, 22 ], [ 3, 6, 10 ], [ 9, 16, 18 ], [ 12, 19, 23 ], [ 17, 18, 25 ], [ 19, 20, 22 ], [ 1, 11, 15 ], [ 4, 7, 26 ], [ 5, 7, 18 ], [ 11, 14, 15 ], [ 6, 10, 14 ], [ 5, 8, 21 ], [ 6, 12, 23 ], [ 19, 20, 22 ], [ 17, 25, 27 ], [ 3, 11, 24 ], [ 4, 15, 21 ], [ 2, 8, 16 ], [ 1, 13, 13 ], [ 2, 13, 26 ],[ 8, 9, 16 ], [ 12, 23, 24 ], [ 10, 20, 27 ], [ 9, 25, 27 ] ]

# here is the data when p=5;nn=2.
#[ [ 1, 2, 3, 5, 18 ], [ 4, 7, 11, 13, 17 ], [ 8, 9, 16, 19, 19 ], [ 5, 6, 12, 12, 20 ], [ 9, 12, 21, 22, 23 ], [ 1, 2, 3, 4, 9 ], [ 6, 7, 8, 11, 24 ], [ 4, 6, 13, 15, 15 ], [ 10, 16, 17, 18, 19 ], [ 21, 22, 23, 24, 25 ], [ 1, 2, 3, 8, 23 ], [ 9, 14, 15, 15, 24 ], [ 5, 11, 13, 20, 20 ], [ 9, 10, 16, 17, 18 ], [ 14, 20, 21, 22, 23 ], [ 2, 3, 4, 6, 14 ], [ 1, 5, 8, 10, 25 ], [ 7, 11, 12, 13, 14 ], [ 10, 16, 17, 18, 19 ], [ 7, 21, 22, 24, 25 ], [ 1, 2, 4, 13, 25 ], [ 3, 5, 12, 20, 24 ], [ 6, 7, 8, 11, 19 ], [ 10, 14, 16, 17, 18 ], [ 15, 21, 22, 23, 25 ] ]

# matrixsort puts the matrix in a special form so that it is easy to understand.

# SELECT PERMUTATIONS HAS BUGS!!!
selectpermutations:=function(oldlist) local rem,list,n,r,output,i,j,k; list:=StructuralCopy(oldlist); n:=Length(list); r:=Length(list[1]); output:=[]; 
for i in [1..n] do output[i]:=[]; od; for i in [1..r] do rem:=[1..n]*0; for j in [1..n] do for k in [1..Length(list[j])] do if rem[list[j][k]]=0 then break; fi; od; 
rem[list[j][k]]:=1; output[j][i]:=list[j][k]; list[j][k]:=list[j][Length(list[j])]; Remove(list[j]); od; od; return output; end;

matrixsort:=function(oldlist)
local n,i,j,c,newlist,list,output,fix,par,invpar;
n:=Length(oldlist);
list:=selectpermutations(oldlist);
while Length(list[1])<Length(list) do
newlist:=[];
for i in [1..n] do 
newlist[i]:=[];
for a in oldlist[i] do
Append(newlist[i],list[a]);
od;
od;
list:=newlist;
od;
fix:=[];
for i in [1..n] do
if i in oldlist[i] then Add(fix,i); fi;
od;

par:=list[Random(fix)];
invpar:=[1..n]*0; for i in [1..n] do invpar[par[i]]:=i; od;

if 0 in invpar then return oldlist; fi;

output:=[]; for i in [1..n] do output[i]:=List(oldlist[par[i]],v->invpar[v]); od;
return output;
end;




onemodulo:=function(x,y) return RemInt(x-1,y)+1; end;

score:=function(array) 
local a,p,n,list,i,k,newlist,j; 
p:=Primes[Random([40..168])]; n:=Length(array); list:=[]; 
for i in [1..n] do list[i]:=Random(GF(p)); od; list[1]:=list[1]-Sum(list); 
for k in [1..n] do newlist:=[]; 
for j in [1..n] do newlist[j]:=0; 
for a in array[j] do 
newlist[j]:=newlist[j]+list[a]; 
od; od; 
list:=newlist; if list=list*0 then return k; fi; 
od; 
return 0;
end;

# We construct a new nilpotent matrix.
p:=2; nn:=6; n:=p^nn; list:=List([1..n],v->[onemodulo((v-1)*p+1,n)..onemodulo(v*p,n)]);
 
# The following loop constructs new nilpotent matrices from old ones.
while true do 
ii:=Random([1..n]); SortBy(list[ii],v->Random([1..n])); newlist:=StructuralCopy(list); a:=Random([1..n]); b:=a; 
while a=b do a:=Random([1..n]); od; 
kk:=Random([1..n]); r:=Remove(newlist[a]); s:=Remove(newlist[b]); Add(newlist[a],s); Add(newlist[b],r); ph:=score(newlist); 
if ph>0 then list:=newlist; Display(ph); fi; 
od;

# For the following code, one starts off with a nilpotent matrix, and the program minimizes the degree of the matrix until the matrix is of minimum degree.
# In the following code, the matrix is kept nilpotent all the time.
# The code works when p=2,nn=7, but it may fall into a local minimum, so one will need to get the loop out of a local minimum manually.

superscore:=function(nn,list) local n,xx,i,a; n:=Length(list); xx:=List([1..n],v->[1..n]*0); 
for i in [1..n] do for a in list[i] do xx[i][a]:=xx[i][a]+1; od; od; return Sum(List(xx^nn-1,v->v*v)); end;

while true do 
ii:=Random([1..n]); SortBy(list[ii],v->Random([1..n])); newlist:=StructuralCopy(list); a:=Random([1..n]); b:=a; 
while a=b do a:=Random([1..n]); od; 
kk:=Random([1..n]); r:=Remove(newlist[a]); s:=Remove(newlist[b]); Add(newlist[a],s); Add(newlist[b],r); ph:=score(newlist); 
if ph>0 then pak:=score(newlist)*superscore(nn,newlist); if pak<=00+superscore(nn,list)*score(list) 
#if ph>0 then pak:=superscore(nn,newlist); if pak<=superscore(nn,list)+20 
then list:=newlist; Display(ph); xx:=[]; for i in [1..n] do xx[i]:=[]; for j in [1..2*n] do xx[i][j]:=' '; od; for a in list[i] do xx[i][a]:='T'; od; od; Display(xx); Display(ph); Display(pak);
fi; fi; 
od;


# It is not very feasible to nilpotent 0-1 matrices simply by declaring the loss function to be 
# the spectral radius and then minimizing this loss function. However, one can produce 0-1 
# matrices A such that A^k is the matrix where each entry is 1 by declaring the loss function of a
# matrix A to be the distance from A^k to the all ones matrix.

sortscore:=function(oldlist)
local a,n,i,j,c,newlist,list;
n:=Length(oldlist);
list:=StructuralCopy(oldlist);
while Length(list[1])<Length(list) do
newlist:=[];
for i in [1..n] do 
newlist[i]:=[];
for a in oldlist[i] do
Append(newlist[i],list[a]);
od;
od;
list:=newlist;
od;

c:=0;
for i in [1..n] do
Sort(list[i]);
for j in [1..n-1] do
if list[i][j]=list[i][j+1] then c:=c+1; fi;
od;
od;
return c;
end;


n:=64; list:=[]; for i in [1..63] do list[i]:=[i,i+1]; od; list[64]:=[64,1];

ph:=sortscore(list);
while true do 
ii:=Random([1..n]); SortBy(list[ii],v->Random([1..n])); newlist:=StructuralCopy(list); a:=Random([1..n]); b:=a; 
while a=b do a:=Random([1..n]); od; 
kk:=Random([1..n]); r:=Remove(newlist[a]); s:=Remove(newlist[b]); Add(newlist[a],s); Add(newlist[b],r); qh:=sortscore(newlist); 
if qh<=ph+Random([0..Random([0..10])]) then list:=newlist; ph:=qh; Display(ph); fi;
od;
